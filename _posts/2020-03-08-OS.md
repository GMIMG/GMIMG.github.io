---
category: ComputerScience
---

# Operating System

이 포스팅은 서울대학교 홍성수 교수님의 공개강좌인 운영체제의 기초 강의를 기반으로 작성했습니다.



## 간단한 역사 

**Phase-1 **Multiprogramming



과거에 진공관으로 만든 CPU가 관리하던 입출력과 같은 Operation을 모니터링(Idle:게으른)해야하는 비효율적인 부분을 하드웨어적인 인터럽트를 통해서 분리해서 사용하게되는데 이러한 방법으로 Operating system이 시작이 된다.

예를들어, Input operation은 대부분 synchronous하게 구현해야한다. 반면 Output operation은 asynchronous하게 할 수 있기도 하다.

멀티프로그래밍을 가능하게도 한다. 하지만 다음과 같은 문제점이 발생하게된다.

- Memory Protection : 어떤 Job이 다른 Job의 memory의 간섭이 생길때

- Memory Relocation : Job이 메인메모리 어느 주소에서도 문제없이 수행되어야함. 

  이러한 MMU(Memory Management Unit)라는 하드웨어유닛은 논리 주소를  물리 주소에 할당하고 경계를 만들어 관리한다. *MMU를 하드웨어로 설계하는 이유는 1. 성능관리 2. 소프트웨어는 역시 위와같은 문제가 발생하기 때문이다.* 단, MMU는 OS에 의해서(만) programmable한 entity이어야만 한다.

- Concurrent Programming 



**Phase-2** Time sharing

트랜지스터가 개발되면서 하드웨어 가격에 비해 programmer의 몸값(인건비)이 올라가서 Idle 한 인력을 줄이기 위해 OS의 역할이 약간 바뀌게된다.

파일 시스템에 권한과 개인폴더를 소유할수있게 바뀌게됨. 



**Phase-3** Multimedia



이처럼 OS의 가장중요한 역할은 **Task scheduler**이다. OS는 사용자가 하드웨어를 효율적으로 사용하면서

